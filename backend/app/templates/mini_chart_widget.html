<!DOCTYPE html>
<html>
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Mini Chart Widget</title>
    <style>
        @import url('https://fonts.googleapis.com/css2?family=Inter:wght@300;400;500;600;700&family=Roboto+Mono:wght@300;400;500;600;700&display=swap');
        
        * {
            margin: 0;
            padding: 0;
            box-sizing: border-box;
        }
        
        body {
            background: transparent;
            font-family: 'Inter', 'Roboto', sans-serif;
            overflow: hidden;
        }
        
        .chart-container {
            width: {{ width }}px;
            height: {{ height }}px;
            background: {{ bg_color }};
            border-radius: {{ border_radius }}px;
            padding: 8px;
            display: flex;
            flex-direction: column;
            box-shadow: 0 2px 8px rgba(0, 0, 0, 0.1);
        }
        
        .chart-header {
            display: flex;
            justify-content: space-between;
            align-items: center;
            margin-bottom: 8px;
        }
        
        .symbol-info {
            display: flex;
            align-items: baseline;
            gap: 8px;
        }
        
        .symbol {
            font-size: 14px;
            font-weight: 600;
            color: {{ text_color }};
        }
        
        .price {
            font-size: 16px;
            font-weight: 700;
            color: {{ text_color }};
            font-variant-numeric: tabular-nums;
        }
        
        .change {
            font-size: 12px;
            font-weight: 500;
            padding: 2px 6px;
            border-radius: 4px;
        }
        
        .change.positive {
            color: {{ up_color }};
            background: {{ up_color }}22;
        }
        
        .change.negative {
            color: {{ down_color }};
            background: {{ down_color }}22;
        }
        
        .change.neutral {
            color: {{ neutral_color }};
            background: {{ neutral_color }}22;
        }
        
        .chart-canvas {
            flex: 1;
            width: 100%;
            border-radius: 4px;
        }
        
        .loading {
            display: flex;
            align-items: center;
            justify-content: center;
            height: 100%;
            color: {{ text_color }}66;
            font-size: 12px;
        }
        
        .error {
            display: flex;
            align-items: center;
            justify-content: center;
            height: 100%;
            color: {{ down_color }};
            font-size: 12px;
        }
    </style>
</head>
<body>
    <div class="chart-container">
        <div class="chart-header">
            <div class="symbol-info">
                <span class="symbol">{{ symbol }}</span>
                <span class="price" id="currentPrice">--.----</span>
            </div>
            <span class="change neutral" id="changePercent">0.00%</span>
        </div>
        <canvas class="chart-canvas" id="chartCanvas"></canvas>
        <div class="loading" id="loadingMessage">Loading chart data...</div>
        <div class="error" id="errorMessage" style="display: none;"></div>
    </div>
    
    <script>
        const config = {
            symbol: '{{ symbol }}',
            hours: {{ hours }},
            maxPoints: {{ max_points }},
            updateInterval: {{ update_interval }},
            smoothing: {{ smoothing }},
            lineColor: '{{ line_color }}',
            fillColor: '{{ fill_color }}',
            upColor: '{{ up_color }}',
            downColor: '{{ down_color }}',
            neutralColor: '{{ neutral_color }}',
            gridColor: '{{ grid_color }}',
            showGrid: {{ show_grid|lower }},
            apiUrl: '/api/mt5/chart-history'
        };
        
        class MiniChart {
            constructor() {
                this.canvas = document.getElementById('chartCanvas');
                this.ctx = this.canvas.getContext('2d');
                this.data = [];
                this.prices = [];
                this.isLoading = true;
                
                this.setupCanvas();
                this.fetchData();
                
                // Update chart data every X seconds (from config)
                setInterval(() => this.fetchData(), config.updateInterval * 1000);
                
                // Update price and percentage from cache every 2 seconds
                setInterval(() => this.updateRealTimePrice(), 2000);
                
                // Handle resize
                window.addEventListener('resize', () => this.setupCanvas());
            }
            
            setupCanvas() {
                const rect = this.canvas.getBoundingClientRect();
                this.canvas.width = rect.width * window.devicePixelRatio;
                this.canvas.height = rect.height * window.devicePixelRatio;
                this.canvas.style.width = rect.width + 'px';
                this.canvas.style.height = rect.height + 'px';
                this.ctx.scale(window.devicePixelRatio, window.devicePixelRatio);
                
                if (!this.isLoading && this.data.length > 0) {
                    this.draw();
                }
            }
            
            async fetchData() {
                try {
                    const response = await fetch(`${config.apiUrl}/${config.symbol}?hours=${config.hours}&max_points=${config.maxPoints}&smoothing=${config.smoothing}`);
                    const result = await response.json();
                    
                    if (!response.ok) {
                        throw new Error(result.detail || 'Failed to fetch data');
                    }
                    
                    if (result.data && result.data.length > 0) {
                        this.data = result.data;
                        this.prices = this.data.map(d => d.price);
                        
                        // Only update chart-specific UI on chart data fetch
                        if (this.isLoading) {
                            this.isLoading = false;
                            document.getElementById('loadingMessage').style.display = 'none';
                            this.canvas.style.display = 'block';
                        }
                        
                        this.draw();
                    }
                } catch (error) {
                    console.error('Error fetching chart data:', error);
                    if (this.isLoading) {
                        document.getElementById('loadingMessage').style.display = 'none';
                        document.getElementById('errorMessage').style.display = 'flex';
                        document.getElementById('errorMessage').textContent = error.message;
                    }
                }
            }
            
            async updateRealTimePrice() {
                try {
                    const response = await fetch(`/price/${config.symbol}`);
                    if (!response.ok) return;
                    
                    const priceData = await response.json();
                    if (priceData && priceData.price && typeof priceData.change_pct !== 'undefined') {
                        const currentPrice = priceData.price;
                        const changePercent = priceData.change_pct; // Use the same calculation as ticker widget
                        
                        // Update price
                        document.getElementById('currentPrice').textContent = currentPrice.toFixed(this.getDecimals());
                        
                        // Update change - same format as ticker widget
                        const changeElement = document.getElementById('changePercent');
                        const arrow = changePercent >= 0 ? '▲' : '▼';
                        changeElement.textContent = `${arrow}${Math.abs(changePercent).toFixed(2)}%`;
                        changeElement.className = `change ${changePercent >= 0 ? 'positive' : 'negative'}`;
                    }
                } catch (error) {
                    console.error('Error fetching real-time price:', error);
                }
            }
            
            getDecimals() {
                const symbol = config.symbol;
                if (symbol.includes('JPY')) return 3;
                if (symbol.includes('XAU') || symbol.includes('XAG')) return 2;
                return 5;
            }
            
            // Add percentile helper
            getPercentile(arr, percentile) {
                if (!arr.length) return 0;
                const sorted = [...arr].sort((a, b) => a - b);
                const index = Math.floor(percentile * (sorted.length - 1));
                return sorted[index];
            }
            
            draw() {
                const ctx = this.ctx;
                const width = this.canvas.width / window.devicePixelRatio;
                const height = this.canvas.height / window.devicePixelRatio;
                
                // Clear canvas
                ctx.clearRect(0, 0, width, height);
                
                if (this.prices.length < 2) return;
                
                // Chart margins - proper padding to prevent overflow
                const margin = {
                    top: 8,
                    right: 8,
                    bottom: 8,
                    left: 8
                };
                
                const chartWidth = width - margin.left - margin.right;
                const chartHeight = height - margin.top - margin.bottom;
                
                // Use percentiles for bounds to avoid outliers
                const minPrice = this.getPercentile(this.prices, 0.05); // 5th percentile
                const maxPrice = this.getPercentile(this.prices, 0.95); // 95th percentile
                const priceRange = maxPrice - minPrice;
                
                // Use minimum 20% padding or at least 0.01% of the price value
                const minPadding = Math.max(priceRange * 0.2, maxPrice * 0.0001);
                const padding = Math.max(priceRange * 0.2, minPadding);
                
                const yMin = minPrice - padding;
                const yMax = maxPrice + padding;
                const yRange = yMax - yMin;
                
                // Draw grid
                if (config.showGrid) {
                    ctx.strokeStyle = config.gridColor;
                    ctx.lineWidth = 0.5;
                    ctx.setLineDash([2, 2]);
                    
                    // Horizontal lines within chart area
                    for (let i = 0; i <= 4; i++) {
                        const y = margin.top + (chartHeight / 4) * i;
                        ctx.beginPath();
                        ctx.moveTo(margin.left, y);
                        ctx.lineTo(margin.left + chartWidth, y);
                        ctx.stroke();
                    }
                    
                    ctx.setLineDash([]);
                }
                
                // Determine line color based on trend
                const firstPrice = this.prices[0];
                const lastPrice = this.prices[this.prices.length - 1];
                const lineColor = lastPrice >= firstPrice ? config.upColor : config.downColor;
                
                // Draw filled area within chart bounds
                ctx.beginPath();
                ctx.moveTo(margin.left, margin.top + chartHeight);
                
                this.prices.forEach((price, i) => {
                    const x = margin.left + (i / (this.prices.length - 1)) * chartWidth;
                    const y = margin.top + ((yMax - price) / yRange) * chartHeight;
                    
                    if (i === 0) {
                        ctx.lineTo(x, y);
                    } else {
                        ctx.lineTo(x, y);
                    }
                });
                
                ctx.lineTo(margin.left + chartWidth, margin.top + chartHeight);
                ctx.closePath();
                
                // Create gradient fill within chart area
                const gradient = ctx.createLinearGradient(0, margin.top, 0, margin.top + chartHeight);
                gradient.addColorStop(0, lineColor + '40');
                gradient.addColorStop(1, lineColor + '05');
                ctx.fillStyle = gradient;
                ctx.fill();
                
                // Draw line within chart bounds - TradingView style
                ctx.beginPath();
                ctx.strokeStyle = lineColor;
                ctx.lineWidth = 1.5;  // Thinner line like TradingView
                ctx.lineCap = 'round';
                ctx.lineJoin = 'round';
                
                this.prices.forEach((price, i) => {
                    const x = margin.left + (i / (this.prices.length - 1)) * chartWidth;
                    const y = margin.top + ((yMax - price) / yRange) * chartHeight;
                    
                    if (i === 0) {
                        ctx.moveTo(x, y);
                    } else {
                        ctx.lineTo(x, y);
                    }
                });
                
                ctx.stroke();
                
                // Draw current price dot - smaller like TradingView
                const lastX = margin.left + chartWidth;
                const lastY = margin.top + ((yMax - lastPrice) / yRange) * chartHeight;
                
                ctx.beginPath();
                ctx.arc(lastX - 2, lastY, 2, 0, Math.PI * 2);  // Smaller dot
                ctx.fillStyle = lineColor;
                ctx.fill();
                
            }
        }
        
        // Initialize chart when DOM is ready
        document.addEventListener('DOMContentLoaded', () => {
            new MiniChart();
        });
    </script>
</body>
</html>