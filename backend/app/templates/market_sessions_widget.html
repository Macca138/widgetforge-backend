<!DOCTYPE html>
<html>
<head>
  <meta charset="UTF-8">
  <meta name="viewport" content="width=600, initial-scale=1.0">
  <title>Market Sessions Widget</title>
  <style>
    @import url('https://fonts.googleapis.com/css2?family=Inter:wght@400;700&display=swap');
    body {
      margin: 0;
      padding: 0;
    }
    .session-widget-container {
      width: 100%;
      max-width: 600px;
      height: 80px;
      display: flex;
      align-items: center;
      justify-content: space-between;
      padding: 0 24px;
      box-sizing: border-box;
      margin: 8px 0;
    }
    .sessions {
      display: flex;
      gap: 24px;
      align-items: center;
      justify-content: flex-start;
      width: auto;
      height: 100%;
    }
    .session {
      display: flex;
      flex-direction: column;
      align-items: center;
      justify-content: center;
      min-width: 80px;
      height: 100%;
      text-align: center;
      padding: 0 8px;
      box-sizing: border-box;
    }
    .session-dot {
      width: 12px;
      height: 12px;
      border-radius: 50%;
      margin-bottom: 4px;
      background: #ff4444;
      display: inline-block;
    }
    .session-dot.open {
      background: #00ff88;
    }
    .session-name {
      color: {{ session_color }};
      font-weight: {{ font_weight }};
      font-size: {{ font_size }}px;
      margin-bottom: 2px;
      letter-spacing: 0.5px;
      line-height: 1.1;
    }
    .session-status {
      font-size: {{ (font_size|int * 0.8)|int }}px;
      color: {{ font_color }};
      font-weight: 400;
      margin-bottom: 0;
      line-height: 1.1;
      min-height: 20px;
      display: flex;
      align-items: center;
      justify-content: center;
    }
    .clock {
      display: flex;
      flex-direction: column;
      align-items: flex-end;
      justify-content: center;
      min-width: 120px;
      height: 100%;
    }
    .clock-label {
      color: {{ clock_color }};
      font-size: {{ (font_size|int * 0.9)|int }}px;
      font-weight: {{ font_weight }};
      margin-bottom: 2px;
      text-align: right;
    }
    .clock-time {
      color: {{ font_color }};
      font-size: {{ (font_size|int * 1.7)|int }}px;
      font-weight: {{ font_weight }};
      letter-spacing: 1px;
      text-align: right;
    }
    @media (max-width: 600px) {
      .session-widget-container { padding: 0 8px; }
      .sessions { gap: 8px; }
      .session { min-width: 60px; }
      .clock { min-width: 80px; }
      .clock-time { font-size: 20px; }
    }
  </style>
</head>
<body>
  <div class="session-widget-container" style="background: {{ bg_color }}; font-family: '{{ font }}', Arial, sans-serif;">
    <div class="sessions" id="sessions"></div>
    <div class="clock">
      <div class="clock-label" id="clock-label" style="color: {{ clock_color }}; font-size: {{ (font_size|int * 0.9)|int }}px; font-weight: {{ font_weight }};"></div>
      <div class="clock-time" id="clock-time" style="color: {{ font_color }}; font-size: {{ (font_size|int * 1.7)|int }}px; font-weight: {{ font_weight }};"></div>
    </div>
  </div>
  <script>
    // Market configs with times in UK time (GMT/BST)
    const marketConfigs = {
      Sydney: {
        start: 22, end: 7, timezone: 10, dst: { start: '10-02', end: '04-02', offset: 1 }
      },
      Tokyo: {
        start: 0, end: 9, timezone: 9, dst: { start: '', end: '', offset: 0 }
      },
      London: {
        start: 8, end: 17, timezone: 0, dst: { start: '03-30', end: '10-27', offset: 1 }
      },
      'New York': {
        start: 13, end: 22, timezone: -5, dst: { start: '03-09', end: '11-02', offset: 1 }
      }
    };
    // Demo holiday calendar (expand as needed)
    const holidays = {
      'Sydney': ['2025-01-01', '2025-12-25', '2025-12-26'],
      'Tokyo': ['2025-01-01', '2025-12-25'],
      'London': ['2025-01-01', '2025-12-25', '2025-12-26'],
      'New York': ['2025-01-01', '2025-07-04', '2025-12-25']
    };
    function pad(n) { return n < 10 ? '0' + n : n; }
    function getDstOffset(market, date) {
      const cfg = marketConfigs[market];
      if (!cfg.dst.start || !cfg.dst.end) return 0;
      const year = date.getUTCFullYear();
      const dstStart = new Date(`${year}-${cfg.dst.start}T02:00:00Z`);
      const dstEnd = new Date(`${year}-${cfg.dst.end}T02:00:00Z`);
      if (dstStart < dstEnd) {
        // Northern hemisphere
        if (date >= dstStart && date < dstEnd) return cfg.dst.offset;
      } else {
        // Southern hemisphere (Sydney)
        if (date >= dstStart || date < dstEnd) return cfg.dst.offset;
      }
      return 0;
    }
    function getMarketLocalTime(utcDate, market) {
      const cfg = marketConfigs[market];
      const offset = cfg.timezone + getDstOffset(market, utcDate);
      const localTime = new Date(utcDate.getTime() + offset * 60 * 60 * 1000);
      return {
        time: localTime,
        offset: offset
      };
    }
    function getUTCFromLocal(localDate, market, offset) {
      return new Date(localDate.getTime() - offset * 60 * 60 * 1000);
    }
    function isWeekend(utcDate, market) {
      const { time: local } = getMarketLocalTime(utcDate, market);
      const day = local.getUTCDay();
      const hour = local.getUTCHours();
      
      if (market === 'Sydney') {
        // Sydney: Closed from Friday 17:00 to Sunday 22:00
        if (day === 6) return true; // All of Saturday
        if (day === 5 && hour >= 17) return true; // Friday after 17:00
        if (day === 0 && hour < 22) return true; // Sunday before 22:00
        return false;
      } else if (market === 'Tokyo') {
        // Tokyo: Closed from Friday 17:00 to Monday 00:00
        if (day === 6) return true; // All of Saturday
        if (day === 0) return true; // All of Sunday
        if (day === 5 && hour >= 17) return true; // Friday after 17:00
        if (day === 1 && hour < 0) return true; // Monday before 00:00
        return false;
      } else if (market === 'London') {
        // London: Closed from Friday 17:00 to Monday 08:00
        if (day === 6) return true; // All of Saturday
        if (day === 0) return true; // All of Sunday
        if (day === 5 && hour >= 17) return true; // Friday after 17:00
        if (day === 1 && hour < 8) return true; // Monday before 08:00
        return false;
      } else if (market === 'New York') {
        // New York: Closed from Friday 22:00 to Monday 13:00
        if (day === 6) return true; // All of Saturday
        if (day === 0) return true; // All of Sunday
        if (day === 5 && hour >= 22) return true; // Friday after 22:00
        if (day === 1 && hour < 13) return true; // Monday before 13:00
        return false;
      }
      
      return false;
    }
    function isHoliday(utcDate, market) {
      const { time: local } = getMarketLocalTime(utcDate, market);
      const y = local.getUTCFullYear();
      const m = pad(local.getUTCMonth() + 1);
      const d = pad(local.getUTCDate());
      const dateStr = `${y}-${m}-${d}`;
      return holidays[market] && holidays[market].includes(dateStr);
    }
    function getNextValidTradingDay(utcDate, market) {
      let d = new Date(utcDate.getTime());
      const { time: local } = getMarketLocalTime(d, market);
      
      // Set the time to the market opening time
      if (market === 'Sydney') {
        // Sydney opens Sunday 22:00
        while (local.getUTCDay() !== 0) {
          d.setUTCDate(d.getUTCDate() + 1);
          local.setUTCDate(local.getUTCDate() + 1);
        }
      } else if (market === 'Tokyo') {
        // Tokyo opens Monday 00:00
        while (local.getUTCDay() !== 1) {
          d.setUTCDate(d.getUTCDate() + 1);
          local.setUTCDate(local.getUTCDate() + 1);
        }
      } else if (market === 'London') {
        // London opens Monday 08:00
        while (local.getUTCDay() !== 1) {
          d.setUTCDate(d.getUTCDate() + 1);
          local.setUTCDate(local.getUTCDate() + 1);
        }
      } else if (market === 'New York') {
        // New York opens Monday 13:00
        while (local.getUTCDay() !== 1) {
          d.setUTCDate(d.getUTCDate() + 1);
          local.setUTCDate(local.getUTCDate() + 1);
        }
      }
      
      // Skip holidays
      while (isHoliday(d, market)) {
        d.setUTCDate(d.getUTCDate() + 1);
      }
      
      return d;
    }
    function getMarketStatus(now, market) {
      const cfg = marketConfigs[market];
      
      // Get UK time (convert from UTC to UK time)
      const ukTime = new Date(now.getTime() + (isDST(now) ? 1 : 0) * 60 * 60 * 1000);
      const ukHour = ukTime.getUTCHours();
      const ukDay = ukTime.getUTCDay();
      
      // Check if it's a holiday
      if (isHoliday(now, market)) {
        const nextOpen = getNextOpenTime(now, market);
        const diffMs = nextOpen - now;
        const diffH = Math.floor(diffMs / (1000 * 60 * 60));
        const diffM = Math.floor((diffMs % (1000 * 60 * 60)) / (1000 * 60));
        return { open: false, status: `Holiday - Opens in ${diffH}h ${pad(diffM)}m` };
      }
      
      // Check if it's weekend
      const isWeekendNow = (ukDay === 6) || (ukDay === 0) || (ukDay === 5 && ukHour >= 17);
      
      if (isWeekendNow) {
        const nextOpen = getNextOpenTime(now, market);
        const diffMs = nextOpen - now;
        const diffH = Math.floor(diffMs / (1000 * 60 * 60));
        const diffM = Math.floor((diffMs % (1000 * 60 * 60)) / (1000 * 60));
        return { open: false, status: `Weekend - Opens in ${diffH}h ${pad(diffM)}m` };
      }
      
      // Check if market is open (using UK time)
      let isOpen;
      if (cfg.start > cfg.end) {
        // Cross-midnight session
        isOpen = (ukHour >= cfg.start || ukHour < cfg.end);
      } else {
        // Regular session
        isOpen = (ukHour >= cfg.start && ukHour < cfg.end);
      }
      
      if (isOpen) {
        // Calculate time until close
        let closeTime = new Date(ukTime);
        if (cfg.start > cfg.end && ukHour < cfg.end) {
          // Already past midnight
          closeTime.setUTCHours(cfg.end, 0, 0, 0);
        } else if (cfg.start > cfg.end && ukHour >= cfg.start) {
          // Before midnight, close is tomorrow
          closeTime.setUTCDate(closeTime.getUTCDate() + 1);
          closeTime.setUTCHours(cfg.end, 0, 0, 0);
        } else {
          // Regular session
          closeTime.setUTCHours(cfg.end, 0, 0, 0);
        }
        
        // Convert back to UTC
        const closeUTC = new Date(closeTime.getTime() - (isDST(closeTime) ? 1 : 0) * 60 * 60 * 1000);
        const diffMs = closeUTC - now;
        const diffH = Math.floor(diffMs / (1000 * 60 * 60));
        const diffM = Math.floor((diffMs % (1000 * 60 * 60)) / (1000 * 60));
        return { open: true, status: `Closes in ${diffH}h ${pad(diffM)}m` };
      } else {
        // Calculate time until open
        const nextOpen = getNextOpenTime(now, market);
        const diffMs = nextOpen - now;
        const diffH = Math.floor(diffMs / (1000 * 60 * 60));
        const diffM = Math.floor((diffMs % (1000 * 60 * 60)) / (1000 * 60));
        return { open: false, status: `Opens in ${diffH}h ${pad(diffM)}m` };
      }
    }
    
    function isDST(date) {
      // UK DST runs from last Sunday in March to last Sunday in October
      const year = date.getUTCFullYear();
      const marchLastSunday = new Date(year, 2, 31);
      marchLastSunday.setUTCDate(31 - marchLastSunday.getUTCDay());
      const octLastSunday = new Date(year, 9, 31);
      octLastSunday.setUTCDate(31 - octLastSunday.getUTCDay());
      
      return date >= marchLastSunday && date < octLastSunday;
    }
    
    function getNextOpenTime(now, market) {
      const cfg = marketConfigs[market];
      let nextOpen = new Date(now);
      
      // Get UK time
      const ukTime = new Date(now.getTime() + (isDST(now) ? 1 : 0) * 60 * 60 * 1000);
      const ukHour = ukTime.getUTCHours();
      const ukDay = ukTime.getUTCDay();
      
      // If it's during the week and before market open time
      if (ukDay >= 1 && ukDay <= 5 && ukHour < cfg.start) {
        nextOpen.setUTCHours(cfg.start, 0, 0, 0);
        return new Date(nextOpen.getTime() - (isDST(nextOpen) ? 1 : 0) * 60 * 60 * 1000);
      }
      
      // Otherwise, find next Sunday 22:00 UK time (Sydney) or Monday start time
      let daysUntilOpen;
      if (market === 'Sydney') {
        // Sydney opens Sunday 22:00 UK time
        daysUntilOpen = (7 - ukDay) % 7;
        if (daysUntilOpen === 0 && ukHour >= 22) daysUntilOpen = 7;
        nextOpen.setUTCDate(nextOpen.getUTCDate() + daysUntilOpen);
        nextOpen.setUTCHours(22, 0, 0, 0);
      } else {
        // Other markets open Monday morning
        daysUntilOpen = (8 - ukDay) % 7;
        if (daysUntilOpen === 0) daysUntilOpen = 7;
        nextOpen.setUTCDate(nextOpen.getUTCDate() + daysUntilOpen);
        nextOpen.setUTCHours(cfg.start, 0, 0, 0);
      }
      
      // Convert back to UTC
      return new Date(nextOpen.getTime() - (isDST(nextOpen) ? 1 : 0) * 60 * 60 * 1000);
    }

    // Render sessions (updated to use robust logic)
    function renderSessions() {
      const now = new Date();
      const nowUTC = new Date(now.getTime() + now.getTimezoneOffset() * 60000);
      const container = document.getElementById('sessions');
      container.innerHTML = '';
      Object.keys(marketConfigs).forEach(market => {
        const { open, status } = getMarketStatus(nowUTC, market);
        container.innerHTML += `
          <div class="session">
            <span class="session-dot${open ? ' open' : ''}"></span>
            <span class="session-name" style="color: {{ session_color }}; font-weight: {{ font_weight }}; font-size: {{ font_size }}px;">${market}</span>
            <span class="session-status" style="color: {{ font_color }}; font-size: {{ (font_size|int * 0.8)|int }}px;">${status}</span>
          </div>
        `;
      });
    }
    // Rotating clock
    let clockIdx = 0;
    const marketList = Object.keys(marketConfigs);
    function renderClock() {
      const market = marketList[clockIdx];
      const now = new Date();
      const { time: local } = getMarketLocalTime(now, market);
      document.getElementById('clock-label').textContent = market + ' Time';
      document.getElementById('clock-time').textContent = `${pad(local.getUTCHours())}:${pad(local.getUTCMinutes())}:${pad(local.getUTCSeconds())}`;
    }
    setInterval(() => {
      clockIdx = (clockIdx + 1) % marketList.length;
      renderClock();
    }, 4000);
    setInterval(() => {
      renderSessions();
      renderClock();
    }, 1000);
    renderSessions();
    renderClock();
  </script>
</body>
</html> 